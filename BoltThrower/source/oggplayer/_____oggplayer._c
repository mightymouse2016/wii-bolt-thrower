// see header file for retained Copyright noticed
//
// Sept 2011, changes applied to removed file reading parts (it was missing supporting setup code)
//			  renamed a few things, deleted a few things and optimised a few things.
//			  anything removed has been left in commented out.
// To-do - dynamically allocate memory in at least two areas of this code (if you care)
//
// (I’m not making any more changes to this as I would like to write my own from scratch )
//
// - Titmouse -
//

#include <asndlib.h>
#include <tremor/ivorbiscodec.h>
#include <tremor/ivorbisfile.h>
#include <gccore.h>
#include <unistd.h>
#include <string.h>

#include "oggplayer.h"

/* functions to read the Ogg file from memory */

static struct OggPlayerInfo
{
	char *mem;
	int size;
	int pos;
} file;

static int f_read(void * punt, int bytes, int blocks, int *f)
{
	int b;
	int c;
//	int d;

	if (bytes * blocks <= 0)
		return 0;

	struct OggPlayerInfo* pBuffer = (struct OggPlayerInfo*) f;

	blocks = bytes * blocks;
	c = 0;

	while (blocks > 0)
	{
		b = blocks;
		if (b > 4096)
			b = 4096;

//		if (*f >= 0x666 && *f <= 0x669)
//		{
//			d = (*f); // - 0x666;
			
			if (pBuffer->size == 0)
				return -1;
			
			if ((pBuffer->pos + b) > pBuffer->size)
				b = pBuffer->size - pBuffer->pos;

			if (b > 0)
			{
				memcpy(punt, pBuffer->mem + pBuffer->pos, b);
				pBuffer->pos += b;
			}
//		}
//		else
//			b = read(*f, ((char *) punt) + c, b);

		if (b <= 0)
		{
			return c / bytes;
		}
		c += b;
		blocks -= b;
	}
	return c / bytes;
}

static int f_seek(int *f, ogg_int64_t offset, int mode)
{
	if(f==NULL) return(-1);


		struct OggPlayerInfo* pBuffer = (struct OggPlayerInfo*) f;

	int k ; //, d;
	mode &= 3;
//	if (*f >= 0x666 && *f <= 0x669)
//	{
//		d = (*f); // - 0x666;
		k = 0;

		if (pBuffer->size == 0)
			return -1;

		if (mode == 0)
		{
			if ((offset) >= pBuffer->size)
			{
				pBuffer->pos = pBuffer->size;
				k = -1;
			}
			else if ((offset) < 0)
			{
				pBuffer->pos = 0;
				k = -1;
			}
			else
				pBuffer->pos = offset;
		}
		if (mode == 1)
		{
			if ((pBuffer->pos + offset) >= pBuffer->size)
			{
				pBuffer->pos = pBuffer->size;
				k = -1;
			}
			else if ((pBuffer->pos + offset) < 0)
			{
				pBuffer->pos = 0;
				k = -1;
			}
			else
				pBuffer->pos += offset;
		}
		if (mode == 2)
		{

			if ((pBuffer->size + offset) >= pBuffer->size)
			{
				pBuffer->pos = pBuffer->size;
				k = -1;
			}
			else if ((pBuffer->size + offset) < 0)
			{
				pBuffer->pos = 0;
				k = -1;
			}
			else
				pBuffer->pos = pBuffer->size + offset;
		}

//	}
//	else
//		k = lseek(*f, (int) offset, mode);

	if (k < 0)
		k = -1;
	else
		k = 0;
	return k;
}

static int f_close(int *f)
{
//	int d;
//	if (*f >= 0x666 && *f <= 0x669)
//	{
//		d = (*f);  // - 0x666;
	
	struct OggPlayerInfo* pBuffer = (struct OggPlayerInfo*) f;


		pBuffer->size = 0;
		pBuffer->pos = 0;
		if (pBuffer->mem)
		{
			pBuffer->mem = (void *) 0;
		}
		return 0;
//	}
//	else
//		return close(*f);
	return 0;
}

static long f_tell(int *f)
{


	int k ; //, d;

//	if (*f >= 0x666 && *f <= 0x669)
//	{
//		d = (*f); // - 0x666;

	struct OggPlayerInfo* pBuffer = (struct OggPlayerInfo*) f;

		k = pBuffer->pos;
//	}
//	else
//		k = lseek(*f, 0, 1);

	return (long) k;
}
//
//static int mem_open(char * ogg, int size)
//{
////	static int one = 1;
//	int n;
////	if (one)
////	{
////		one = 0;
////		for (n = 0; n < 4; n++)
////			file[n].size = 0;
////	}
//
//	n=0;
//
////	for (n = 0; n < 4; n++)
////	{
////		if (file[n].size == 0)
////		{
//			file.mem = ogg;
//			file.size = size;
//			file.pos = 0;
//			//return (0x666 + n);
//			return (n);
////		}
////	}
////	return -1;
//}

//static int mem_close(int fd)
//{
////	if (fd >= 0x666 && fd <= 0x669) // it is a memory file descriptor?
////	{
//		//fd -= 0x666;
//		file.size = 0;
//		return 0;
////	}
////	else
////		return f_close(&fd);
//}

static ov_callbacks callbacks = {
	(size_t (*)(void *, size_t, size_t, void *))  f_read,
	(int (*)(void *, ogg_int64_t, int))           f_seek,
	(int (*)(void *))                             f_close,
	(long (*)(void *))                            f_tell
};

/* OGG control */

#define READ_SAMPLES 4096 // samples that it must read before to send
#define MAX_PCMOUT 4096 // minimum size to read ogg samples
typedef struct
{
	OggVorbis_File vf;
	vorbis_info *vi;

	//number of the current logical bitstream, things kind of thing it's fixed at ZERO
	//int current_section;  

	// OGG file operation
//	int fd;
	int ContinuousPlay;  //was ... mode
	int eof;
	int flag;
	int volume;
	int seek_time;
	int VoiceFormat;   // holds something like VOICE_STEREO_16BIT.. holding this here cuts back on logic

	/* OGG buffer control */
	short pcmout[2][READ_SAMPLES + MAX_PCMOUT * 2]; /* take 4k out of the data segment, not the stack */

	// the 4k comment does not ring true, this may be setting aside more than needed, hard to say with a hard coded 4096
	// floating about in the code and READ_SAMPLES, MAX_PCMOUT use that 4096 as well

	int DoubleBufferToggle;  //was .. pcmout_pos !
	int pcm_indx;

} private_data_ogg;

static private_data_ogg private_ogg;

// OGG thread control

#define STACKSIZE		8192

static u8 oggplayer_stack[STACKSIZE];
static lwpq_t oggplayer_queue = LWP_TQUEUE_NULL;
static lwp_t h_oggplayer = LWP_THREAD_NULL;
static int ogg_thread_running = 0;

//static void ogg_add_callback(int voice)
static void ogg_add_callback_for_SetVoice(int voice)
{
	if (!ogg_thread_running)
	{
		ASND_StopVoice(0);
		return;
	}

	if (private_ogg.flag & 128)   // why not call StatusOgg????
		return; // Ogg is paused

	if (private_ogg.pcm_indx >= READ_SAMPLES)
	{
		if (ASND_AddVoice(0,
				(void *) private_ogg.pcmout[private_ogg.DoubleBufferToggle],
				private_ogg.pcm_indx << 1) == 0)
		{
			private_ogg.DoubleBufferToggle ^= 1;
			private_ogg.pcm_indx = 0;
			private_ogg.flag = 0;
			LWP_ThreadSignal(oggplayer_queue);
		}
	}
	else
	{
		if (private_ogg.flag & 64)
		{
			private_ogg.flag &= ~64;
			LWP_ThreadSignal(oggplayer_queue);
		}
	}
}

static void * ogg_player_thread(private_data_ogg * priv)
{
	int first_time = 1;
	long ret;

	// thread synchronization queue
	LWP_InitQueue(&oggplayer_queue);

	// fill out OggVorbis_File struct with the ogg streams details information
	priv[0].vi = ov_info(&priv[0].vf, -1); 

	ASND_Pause(0);

	// Can oggs support more complex playback then this can support?
	// Anyway for this player we don't care, avoid streams that change voice format on the fly (if that's even possible?).
	
	// new code added
	if (priv[0].vi->channels == 2)
		priv[0].VoiceFormat =  VOICE_STEREO_16BIT;
	else
		priv[0].VoiceFormat =  VOICE_MONO_16BIT;
	

	priv[0].pcm_indx = 0;
	priv[0].DoubleBufferToggle = 0;
	priv[0].eof = 0;
	priv[0].flag = 0;
	//priv[0].current_section = 0;

	ogg_thread_running = 1;

	int bitstream = 0;

	while (!priv[0].eof && ogg_thread_running)
	{
		if (priv[0].flag)
			LWP_ThreadSleep(oggplayer_queue); // wait only when i have samples to send

		if (priv[0].flag == 0) // wait to all samples are sent
		{
			if (ASND_TestPointer(0, priv[0].pcmout[priv[0].DoubleBufferToggle])
					&& ASND_StatusVoice(0) != SND_UNUSED)
			{
				priv[0].flag |= 64;
				continue;
			}
			if (priv[0].pcm_indx < READ_SAMPLES)
			{
				priv[0].flag = 3; // 3 00000011  ?? this just gets masked out later on????

				if (priv[0].seek_time >= 0)
				{
					ov_time_seek(&priv[0].vf, priv[0].seek_time);
					priv[0].seek_time = -1;
				}

				ret	= ov_read( &priv[0].vf,
							   (void *) &priv[0].pcmout[priv[0].DoubleBufferToggle][priv[0].pcm_indx],
							   MAX_PCMOUT, &bitstream);

				priv[0].flag &= 192;  //128+64 11000000
				// above might as well read...  priv[0].flag = 192

				if (ret == 0)
				{
					/* EOF */
					if (priv[0].ContinuousPlay & 1)
						ov_time_seek(&priv[0].vf, 0); // repeat
					else
						priv[0].eof = 1; // stops
				}
				else if (ret < 0)
				{
					/* error in the stream.  Not a problem, just reporting it in
					 case we (the app) cares.  In this case, we don't. */
					if (ret != OV_HOLE)
					{
						if (priv[0].ContinuousPlay & 1)
							ov_time_seek(&priv[0].vf, 0); // repeat
						else
							priv[0].eof = 1; // stops
					}
				}
				else
				{
					/* we don't bother dealing with sample rate changes, etc, but
					 you'll have to*/
					priv[0].pcm_indx += ret >> 1; //get 16 bits samples
				}
			}
			else
				priv[0].flag = 1;
		}

		if (priv[0].flag == 1)
		{
			if (ASND_StatusVoice(0) == SND_UNUSED || first_time)
			{
				first_time = 0;
				//if (priv[0].vi->channels == 2)
				//{
				//	ASND_SetVoice(0, VOICE_STEREO_16BIT, priv[0].vi->rate, 0,
				//			(void *) priv[0].pcmout[priv[0].DoubleBufferToggle],
				//			priv[0].pcm_indx << 1, priv[0].volume,
				//			priv[0].volume, ogg_add_callback);
				//	priv[0].DoubleBufferToggle ^= 1;
				//	priv[0].pcm_indx = 0;
				//	priv[0].flag = 0;
				//}
				//else
				//{
				//	ASND_SetVoice(0, VOICE_MONO_16BIT, priv[0].vi->rate, 0,
				//			(void *) priv[0].pcmout[priv[0].DoubleBufferToggle],
				//			priv[0].pcm_indx << 1, priv[0].volume,
				//			priv[0].volume, ogg_add_callback);
				//	priv[0].DoubleBufferToggle ^= 1;
				//	priv[0].pcm_indx = 0;
				//	priv[0].flag = 0;
				//}

				ASND_SetVoice(0, priv[0].VoiceFormat, priv[0].vi->rate, 0,
					(void *) priv[0].pcmout[priv[0].DoubleBufferToggle],
					priv[0].pcm_indx << 1, priv[0].volume,
					priv[0].volume, ogg_add_callback_for_SetVoice);

				priv[0].DoubleBufferToggle ^= 1;
				priv[0].pcm_indx = 0;
				priv[0].flag = 0;
			}
		}

		// need to look into this sleep value of 100 , looks like this could be increased
		// using double buffer so thinking this should be calculated for the playback time of a buffer with add little added for delays
		usleep(100);  
	}
	ov_clear(&priv[0].vf);
	//priv[0].fd = -1;
	priv[0].pcm_indx = 0;

	return 0;
}

void StopOgg()
{
	ASND_StopVoice(0);
	ogg_thread_running = 0;

	if(h_oggplayer != LWP_THREAD_NULL)
	{
		if(oggplayer_queue != LWP_TQUEUE_NULL)
			LWP_ThreadSignal(oggplayer_queue);
		LWP_JoinThread(h_oggplayer, NULL);
		h_oggplayer = LWP_THREAD_NULL;
	}
	if(oggplayer_queue != LWP_TQUEUE_NULL)
	{
		LWP_CloseQueue(oggplayer_queue);
		oggplayer_queue = LWP_TQUEUE_NULL;
	}
}

int PlayOgg(const void *buffer, s32 len, int time_pos, int mode)
{
	StopOgg();

	//private_ogg.fd = mem_open((char *)buffer, len);

	// added this section - see deleted mem_open
	file.mem = (char*) buffer;
	file.size = len;
	file.pos = 0;

	//if (private_ogg.fd < 0)
	//{
	//	private_ogg.fd = -1;
	//	return -1;
	//}

	private_ogg.ContinuousPlay = mode;
	private_ogg.eof = 0;
	private_ogg.volume = 127;
	private_ogg.flag = 0;
	private_ogg.seek_time = -1;

	if (time_pos > 0)
		private_ogg.seek_time = time_pos;

	//if (ov_open_callbacks((void *) &private_ogg.fd, &private_ogg.vf, NULL, 0, callbacks) < 0)
	if (ov_open_callbacks((void *) &file, &private_ogg.vf, NULL, 0, callbacks) < 0)
	{
	//	mem_close(private_ogg.fd); // mem_close() can too close files from devices

		file.size = 0;

	//	private_ogg.fd = -1;
		ogg_thread_running = 0;
		return -1;
	}
	
	// notes: LWP_PRIO_IDLE 0, LWP_PRIO_HIGHEST 127
	// This code was unsing 80, I found this a little hungry, using 64 instead.
	// Maybe possible to dynamicaly calculate this value

	if (LWP_CreateThread(&h_oggplayer, (void *) ogg_player_thread,
			&private_ogg, oggplayer_stack, STACKSIZE, 64 ) == -1)
	{
		ogg_thread_running = 0;
		ov_clear(&private_ogg.vf);
//		private_ogg.fd = -1;
		return -1;
	}
	return 0;
}

void PauseOgg(int pause)
{
	if (pause)
	{
		private_ogg.flag |= 128;
	}
	else
	{
		if (private_ogg.flag & 128)
		{
			private_ogg.flag |= 64;
			private_ogg.flag &= ~128;
			if (ogg_thread_running > 0)
			{
				LWP_ThreadSignal(oggplayer_queue);
			}
		}
	}
}

int StatusOgg()
{
	if (ogg_thread_running == 0)
		return -1; // Error
	else if (private_ogg.eof)
		return 255; // EOF
	else if (private_ogg.flag & 128)
		return 2; // paused
	else
		return 1; // running
}

void SetVolumeOgg(int volume)
{
	private_ogg.volume = volume;
	ASND_ChangeVolumeVoice(0, volume, volume);
}

s32 GetTimeOgg()
{
	int ret;
	if (ogg_thread_running == 0 ) //|| private_ogg.fd < 0)
		return -1;
	ret = ((s32) ov_time_tell(&private_ogg.vf));

	return ret;
}

void SetTimeOgg(s32 time_pos)
{
	if (time_pos >= 0)
		private_ogg.seek_time = time_pos;
}
